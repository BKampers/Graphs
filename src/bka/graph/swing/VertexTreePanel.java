/*
** Copyright Â© Bart Kampers
*/


package bka.graph.swing;


import bka.graph.Vertex;
import java.awt.*;
import java.util.*;
import javax.swing.tree.*;


class VertexTreePanel extends javax.swing.JPanel {


    VertexTreePanel(GraphEditor graphEditor) {
        this.graphEditor = graphEditor;
        initComponents();
        tree.setCellRenderer(new CellRenderer());
        tree.addMouseListener(MOUSE_ADAPTER);
    }
    
    
    void rebuild() {
        ROOT_NODE.removeAllChildren();
        for (DiagramComponent diagramComponent : graphEditor.getDiagramComponents()) {
            DiagramNode diagramNode = new DiagramNode(diagramComponent);
            ROOT_NODE.add(diagramNode);
            for (VertexPicture vertexPicture : diagramComponent.getVertexPictures()) {
                VertexPictureNode vertexPictureNode = new VertexPictureNode(vertexPicture, diagramComponent);
                diagramNode.add(vertexPictureNode);
            }
        }
        MODEL.nodeStructureChanged(ROOT_NODE);
        Enumeration en = ROOT_NODE.children();
        while (en.hasMoreElements()) {
            DiagramNode diagramNode = (DiagramNode) en.nextElement();
            expand(diagramNode);
        }
    }
    
    
    void diagramEntered(java.awt.event.MouseEvent evt) {
        if (dragInfo != null) {
            dragInfo.diagramComponent = (DiagramComponent) evt.getComponent();
        }
    }
    
    
    void diagramExited() {
        if (dragInfo != null) {
            dragInfo.diagramComponent = null;
        }
    }
    
    
    void diagramModified(DiagramComponent diagramComponent) {
        DiagramNode diagramNode = findDiagramNode(diagramComponent);
        if (diagramNode != null) {
            MODEL.nodeChanged(diagramNode);
        }
    }
    
    
    void vertexAdded(VertexPicture vertexPicture, DiagramComponent diagramComponent) {
        DefaultMutableTreeNode parentNode = findNode(diagramComponent);
        VertexPictureNode vertexNode = new VertexPictureNode(vertexPicture, diagramComponent);
        parentNode.add(vertexNode);
        MODEL.nodeStructureChanged(parentNode);
        expand(parentNode);
    }
    
    
    void vertexModified(VertexPicture vertexPicture) {
        DefaultMutableTreeNode vertexNode = findNode(vertexPicture);
        if (vertexNode != null) {
            MODEL.nodeChanged(vertexNode);
        }
    }
    
    
    void vertexRemoved(VertexPicture vertexPicture) {
        DefaultMutableTreeNode vertexPictureNode = findNode(vertexPicture);
        if (vertexPictureNode != null) {
            TreeNode parent = vertexPictureNode.getParent();
            vertexPictureNode.removeFromParent();
            MODEL.nodeStructureChanged(parent);
        }
    }
    
    
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        javax.swing.JScrollPane scrollPane = new javax.swing.JScrollPane();
        tree = new javax.swing.JTree();

        setMinimumSize(new java.awt.Dimension(200, 300));

        tree.setModel(MODEL);
        tree.setRootVisible(false);
        scrollPane.setViewportView(tree);

        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(scrollPane, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 200, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(scrollPane, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    
    private VertexClassNode getVertexClassNode(Class vertexClass) {
        VertexClassNode vertexClassNode = (VertexClassNode) findNode(vertexClass);
        if (vertexClassNode == null) {
            vertexClassNode = new VertexClassNode(vertexClass);
            ROOT_NODE.add(vertexClassNode);
            MODEL.nodeStructureChanged(ROOT_NODE);
        }
        return vertexClassNode;
    }
    
    
    private DiagramNode findDiagramNode(DiagramComponent diagramComponent) {
        Enumeration en = ROOT_NODE.children();
        while (en.hasMoreElements()) {
            DiagramNode node = (DiagramNode) en.nextElement();
            if (node.getUserObject() == diagramComponent) {
                return node;
            }
        }
        return null;
    }

    
    private DefaultMutableTreeNode findNode(Object userObject) {
        return findNode(userObject, ROOT_NODE);
    }
    
    
    private DefaultMutableTreeNode findNode(Object userObject, DefaultMutableTreeNode parent) {
        Enumeration en = parent.children();
        while (en.hasMoreElements()) {
            DefaultMutableTreeNode child = (DefaultMutableTreeNode) en.nextElement();
            if (child.getUserObject() == userObject) {
                return child;
            }
            else {
                DefaultMutableTreeNode node = findNode(userObject, child);
                if (node != null) {
                    return node;
                }
            }
        }
        return null;
    }

    
    private void expand(DefaultMutableTreeNode node) {
        TreeNode[] pathNodes = node.getPath();
        TreePath treePath = new TreePath(pathNodes);
        tree.expandPath(treePath);
    }
    
    
    private class DiagramNode extends DefaultMutableTreeNode {
    
        DiagramNode(DiagramComponent diagramComponent) {
            super(diagramComponent);
        }
        
        @Override
        public String toString() {
            return ((DiagramComponent) getUserObject()).getTitle();
        }
    
    }
    
    
    private class VertexClassNode extends DefaultMutableTreeNode {
        
        VertexClassNode(Class vertexClass) {
            super(vertexClass);
        }
        
        @Override
        public String toString() {
            return ((Class) getUserObject()).getSimpleName();
        }
        

    }
    
    
    private class VertexPictureNode extends DefaultMutableTreeNode {
        
        VertexPictureNode(VertexPicture vertexPicture, DiagramComponent diagramComponent) {
            super(vertexPicture);
            this.diagramComponent = diagramComponent;
        }
        
        @Override
        public String toString() {
            VertexPicture vertexPicture = ((VertexPicture) getUserObject());
            Vertex vertex = vertexPicture.getVertex();
            assert vertex != null;
            String name = vertex.getName();
            if (name == null) {
                name = vertex.getClass().getSimpleName();
            }
            VertexPicture container = diagramComponent.findContainer((VertexPicture) getUserObject());
            if (container != null) {
                assert container.getVertex() != null;
                String containerName = container.getVertex().getName();
                if (containerName != null) {
                    name += " @ " + container.getVertex().getName();
                }
            }
            return (name != null) ? name : vertex.getClass().getSimpleName();
        }
        
        DiagramComponent diagramComponent;
        javax.swing.Icon icon;

    }
    
    
    private class VertexNode extends DefaultMutableTreeNode {
        
        VertexNode(Vertex vertex) {
            super(vertex);
        }
        
    }
    
    
    static class CellRenderer extends DefaultTreeCellRenderer {

        @Override
        public Component getTreeCellRendererComponent(javax.swing.JTree tree, java.lang.Object value, boolean selected, boolean expanded, boolean leaf, int row, boolean hasFocus) {
            super.getTreeCellRendererComponent(tree, value, selected, expanded, leaf, row, hasFocus);
            createIcon(value);
            return this;
        }
        
        private void createIcon(java.lang.Object value) {
            java.lang.Class nodeClass = value.getClass();
            if (value instanceof VertexPictureNode) {
                nodeClass = ((VertexPictureNode) value).getUserObject().getClass();
            }
            synchronized (ICONS) {
                javax.swing.Icon icon = null;
                if (ICONS.containsKey(nodeClass)) {
                    icon = ICONS.get(nodeClass);
                }
                else {
                    if (value instanceof VertexPictureNode) {
                        icon = ((VertexPicture) ((VertexPictureNode) value).getUserObject()).createIcon(16, 14);
                        ICONS.put(nodeClass, icon);
                    }
                }
                if (icon != null) {
                    setIcon(icon);
                }
            }
        } 
    }
    
    
    private class DragInfo {
        
        DiagramComponent diagramComponent;

    }
    
    
    private final java.awt.event.MouseAdapter MOUSE_ADAPTER = new java.awt.event.MouseAdapter() {
        
        @Override
        public void mousePressed(java.awt.event.MouseEvent evt) {
            TreePath path = tree.getPathForLocation(evt.getX(), evt.getY());
            DefaultMutableTreeNode node = (DefaultMutableTreeNode) path.getLastPathComponent();
            if (node instanceof VertexPictureNode) {
                dragInfo = new DragInfo();
                Toolkit toolkit = Toolkit.getDefaultToolkit();
                VertexPicture picture = (VertexPicture) node.getUserObject();
                Image image = picture.createImage(16, 14);
                int width = image.getWidth(VertexTreePanel.this);
                int height = image.getHeight(VertexTreePanel.this);
                Cursor cursor = toolkit.createCustomCursor(image, new Point(width/2, height/2), "VertexCursor");
                VertexTreePanel.this.setCursor(cursor);
            }

        }
        
        @Override
        public void mouseReleased(java.awt.event.MouseEvent evt) {
            if (dragInfo != null) {
                DefaultMutableTreeNode selectedNode = (DefaultMutableTreeNode) tree.getSelectionPath().getLastPathComponent();
                if (selectedNode instanceof VertexPictureNode && dragInfo.diagramComponent != null) {
                    VertexPicture selectedPicture = (VertexPicture) selectedNode.getUserObject();
                    dragInfo.diagramComponent.addVertexPictureCopy(selectedPicture, evt.getLocationOnScreen());
                }
            }
            dragInfo = null;
            VertexTreePanel.this.setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
        }
        
        
    };

    
    private final GraphEditor graphEditor;
    
    
    private DragInfo dragInfo = null;
    

    private final DefaultMutableTreeNode ROOT_NODE = new DefaultMutableTreeNode();
    private final DefaultTreeModel MODEL = new DefaultTreeModel(ROOT_NODE);
    
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTree tree;
    // End of variables declaration//GEN-END:variables

    
    private static final Map<java.lang.Class, javax.swing.Icon> ICONS = new HashMap<java.lang.Class, javax.swing.Icon>();

    
}
